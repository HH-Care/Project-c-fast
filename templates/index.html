<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Real-time Object Tracking</title>
    <style>
        :root {
            --military-dark: #1a1f1c;
            --military-green: #4b5320;
            --accent-green: #87a330;
            --gunmetal: #2a3439;
            --light-gray: #c4c8c5;
            --tactical-red: #a33030;
            --border-radius: 6px;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: 'Roboto', sans-serif;
            background: var(--military-dark);
            color: var(--light-gray);
            min-height: 100vh;
            background-image: 
                linear-gradient(45deg, rgba(43, 48, 43, 0.1) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(43, 48, 43, 0.1) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(43, 48, 43, 0.1) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(43, 48, 43, 0.1) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .config-panel {
            width: 300px;
            background: var(--gunmetal);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section {
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section-title {
            color: var(--accent-green);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--military-green);
            padding-bottom: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--light-gray);
        }

        .form-group input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
            margin-bottom: 10px;
        }

        button {
            background: var(--military-green);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }

        button:hover {
            background: var(--accent-green);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(1px);
        }

        button.danger {
            background: var(--tactical-red);
        }

        button.danger:hover {
            background: #bf3a3a;
        }

        .help-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 8px;
        }

        .status {
            font-size: 14px;
            color: var(--light-gray);
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            border-left: 3px solid var(--military-green);
        }

        .status.error {
            border-left: 3px solid var(--tactical-red);
        }

        .status.success {
            border-left: 3px solid var(--accent-green);
        }

        .status.warning {
            border-left: 3px solid #e9c46a;
        }

        /* Camera status indicator */
        .camera-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #555;
        }

        .camera-indicator.active {
            background-color: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .video-container {
            flex: 1;
            background: var(--gunmetal);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-section {
            background: var(--military-dark);
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
            aspect-ratio: 16/9;
            border: 1px solid var(--military-green);
        }

        #videoFeed {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: block;
        }

        #videoFeed.active {
            opacity: 1;
        }

        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: none;
            z-index: 3;
        }

        .drawing-active #drawCanvas {
            display: block !important;
        }

        .drawing-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 4;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid var(--military-green);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .drawing-active .drawing-controls {
            opacity: 1;
            pointer-events: auto;
        }

        .drawing-btn {
            background: var(--military-green);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            min-width: 120px;
            display: none;
            opacity: 0;
            transform: translateY(10px);
        }

        /* Fix for config panel buttons */
        .section .drawing-btn {
            display: block;
            opacity: 1;
            transform: none;
        }

        .drawing-active .drawing-btn {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .drawing-btn:hover {
            background: var(--accent-green);
            transform: translateY(-2px);
        }

        .drawing-btn.active {
            background: var(--accent-green);
            box-shadow: 0 0 10px rgba(135, 163, 48, 0.3);
        }

        .drawing-btn.secondary {
            background: var(--gunmetal);
        }

        .drawing-btn.secondary:hover {
            background: var(--military-green);
        }

        #confirmDrawBtn {
            background: var(--military-green);
            transition: all 0.3s ease;
        }

        #confirmDrawBtn.active {
            background: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
        }

        .playback-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4;
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid var(--military-green);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            background: var(--military-green);
            border: none;
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            padding: 0;
        }

        .control-btn:hover {
            background: var(--accent-green);
            transform: scale(1.1);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
            stroke: currentColor;
            stroke-width: 1;
        }

        .placeholder-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--light-gray);
        }

        .placeholder-logo {
            width: 100px;
            height: 100px;
            background: var(--military-green);
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            border: 3px solid var(--accent-green);
            box-shadow: 0 0 20px rgba(135, 163, 48, 0.2);
        }

        .select-input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tab-btn {
            background: var(--gunmetal);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: var(--military-green);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .checkbox-wrapper input[type="checkbox"] {
            margin-right: 8px;
        }

        .camera-status {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        /* Fix logo size */
        .logo-section img {
            max-width: 100px;
            height: auto;
            margin-bottom: 10px;
        }

        .logo-section h1 {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .input-with-button {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-with-button input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
        }
    </style>
  </head>
  <body>
    <div class="container">
        <!-- Left Configuration Panel -->
        <div class="config-panel">
            <!-- Logo Section -->
            <div class="logo-section">
                <img src="/static/images/logo.png" alt="System Logo">
                <h1> Real-time Object Tracking</h1>
                <p>Advanced AI-Powered Detection System</p>
            </div>

            <div class="section">
                <div class="section-title">Video Source</div>
                <div class="tabs">
                    <button class="tab-btn active" onclick="switchTab('upload-tab')">Upload Video</button>
                    <button class="tab-btn" onclick="switchTab('webcam-tab')">Webcam</button>
                </div>
                
                <!-- Video Upload Tab (existing functionality) -->
                <div id="upload-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="videoFile">Upload Video File</label>
                        <input type="file" id="videoFile" accept="video/*">
                        <button onclick="uploadVideo()">Upload Video</button>
                        <div id="uploadStatus" class="status"></div>
                    </div>
                </div>
                
                <!-- Webcam Tab (new functionality) -->
                <div id="webcam-tab" class="tab-content">
                    <div class="form-group">
                        <label for="cameraSelect">Select Camera</label>
                        <select id="cameraSelect" class="select-input">
                            <option value="0">Loading cameras...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div class="camera-status">
                            <span class="camera-indicator" id="cameraIndicator"></span>
                            Camera Status: <span id="cameraStatusText">Not connected</span>
                        </div>
                        <div class="button-group">
                            <button id="startWebcamBtn" onclick="startWebcam()">Start Webcam</button>
                            <button id="stopWebcamBtn" onclick="stopWebcam()" disabled>Stop Webcam</button>
                        </div>
                        <div id="webcamStatus" class="status"></div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="webcamTrackingToggle" checked onchange="toggleWebcamTracking()">
                            <label for="webcamTrackingToggle">Enable Tracking</label>
                        </div>
                        <div class="help-text">Toggle real-time tracking of objects</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Drawing Controls</div>
                <button id="drawModeBtn" style="display: block; background: var(--military-green); color: white; text-transform: uppercase;" onclick="toggleDrawingMode()">Enable Drawing Mode</button>
                <button onclick="clearSelection()" style="display: block; margin-top: 10px; background: var(--gunmetal); color: white; text-transform: uppercase;">Clear Selection</button>
                <div class="help-text">Draw a box around the object you want to track</div>
            </div>

            <div class="section">
                <div class="section-title">Server Controls</div>
                <div class="form-group">
                    <button class="danger" onclick="shutdownServer()">Shutdown Server</button>
                    <div class="help-text">Safely stop the server and clean up resources</div>
                </div>
            </div>
        </div>

        <!-- Right Video Display -->
    <div class="video-container">
            <div class="video-section">
                <img id="videoFeed" src="" alt="Video Feed">
                <canvas id="drawCanvas"></canvas>
                <div class="drawing-controls">
                    <button id="confirmDrawBtn" style="display: block; min-width: 120px; margin: 0; padding: 8px 16px; font-size: 14px;">Confirm Selection</button>
                    <button id="cancelDrawBtn" class="secondary" style="display: block; min-width: 120px; margin: 0; padding: 8px 16px; font-size: 14px;">Cancel</button>
                </div>
                <div id="placeholder" class="placeholder-content">
                    <div class="placeholder-logo"></div>
                    <h2> Real-time Tracking</h2>
                    <p>Upload a video to begin analysis</p>
                </div>
                <div class="playback-controls">
                    <button class="control-btn" id="playBtn" onclick="togglePlay()" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="stopBtn" onclick="stopVideo()" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 6h12v12H6z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="videoStatus" class="status">No video loaded</div>
    </div>
    </div>

    <!-- Add this HTML element right before the closing </body> tag -->
    <div id="client-webcam-container" style="display: none;">
        <video id="clientWebcam" autoplay playsinline style="display: none;"></video>
        <canvas id="clientCanvas" style="display: none;"></canvas>
    </div>

    <script>
        let currentVideo = null;
        let selectedObjectId = null;
        let isPlaying = false;
        let videoStream = null;
        let currentFrameIndex = 0;
        let isDrawingMode = false;
        let isDrawing = false;
        let startX, startY;
        let currentRect = null;
        let activeSource = 'video'; // 'video' or 'webcam'

        const videoFeed = document.getElementById('videoFeed');
        const drawCanvas = document.getElementById('drawCanvas');
        const confirmBtn = document.getElementById('confirmDrawBtn');
        const cancelBtn = document.getElementById('cancelDrawBtn');
        const ctx = drawCanvas.getContext('2d');

        let clientWebcamStream = null;
        let isClientWebcamActive = false;
        let clientWebcamInterval = null;

        function initializeCanvas() {
            drawCanvas.width = videoFeed.offsetWidth;
            drawCanvas.height = videoFeed.offsetHeight;
        }

        function setupDrawingListeners() {
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', endDrawing);
            drawCanvas.addEventListener('mouseout', endDrawing);
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = drawCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            currentRect = {
                x: startX,
                y: startY,
                width: 0,
                height: 0
            };
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = drawCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            currentRect.width = currentX - startX;
            currentRect.height = currentY - startY;

            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
        }

        function endDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentRect) {
                confirmBtn.classList.add('active');
            }
        }

        function clearDrawing() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            currentRect = null;
            confirmBtn.classList.remove('active');
        }

        function toggleDrawingMode() {
            // Don't enter drawing mode if no video is loaded or webcam isn't started
            if ((!currentVideo && activeSource === 'video') || 
                (activeSource === 'webcam' && !document.getElementById('stopWebcamBtn').disabled === false)) {
                document.getElementById('videoStatus').textContent = 'Please load a video or start the webcam first';
                return;
            }
            
            isDrawingMode = !isDrawingMode;
            const videoSection = document.querySelector('.video-section');
            const drawModeBtn = document.getElementById('drawModeBtn');
            const drawCanvas = document.getElementById('drawCanvas');
            const drawingControls = document.querySelector('.drawing-controls');
            
            console.log("Drawing mode toggled:", isDrawingMode);
            
            if (isDrawingMode) {
                document.getElementById('videoStatus').textContent = 'Drawing mode: Select an object to track';
                videoSection.classList.add('drawing-active');
                drawModeBtn.classList.add('active');
                drawModeBtn.textContent = 'Drawing Mode Active';
                drawCanvas.style.display = 'block';
                drawingControls.style.opacity = '1';
                drawingControls.style.pointerEvents = 'auto';
                initializeCanvas();
                setupDrawingListeners();
                console.log("Added drawing-active class");
            } else {
                if (activeSource === 'webcam') {
                    document.getElementById('videoStatus').textContent = 'Webcam streaming active';
                } else {
                    document.getElementById('videoStatus').textContent = 'Video playback active';
                }
                videoSection.classList.remove('drawing-active');
                drawModeBtn.classList.remove('active');
                drawModeBtn.textContent = 'Enable Drawing Mode';
                drawCanvas.style.display = 'none';
                drawingControls.style.opacity = '0';
                drawingControls.style.pointerEvents = 'none';
                clearDrawing();
                console.log("Removed drawing-active class");
            }
        }

        confirmBtn.addEventListener('click', async () => {
            if (!currentRect) return;
            
            const rect = {
                bbox: {
                    x: currentRect.x / drawCanvas.width,
                    y: currentRect.y / drawCanvas.height,
                    width: Math.abs(currentRect.width) / drawCanvas.width,
                    height: Math.abs(currentRect.height) / drawCanvas.height
                }
            };

            document.getElementById('videoStatus').textContent = 'Processing selection...';

            try {
                const response = await fetch('/select_object', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(rect)
                });

                const data = await response.json();
                if (data.success) {
                    selectedObjectId = data.selected_id;
                    
                    if (data.method === "detector_refined") {
                        console.log(`Object tracking initialized with detector refinement. ID: ${selectedObjectId}, Confidence: ${(data.confidence * 100).toFixed(1)}%, IoU: ${(data.iou * 100).toFixed(1)}%`);
                        document.getElementById('videoStatus').textContent = `Tracking initialized: Detector refined selection (Confidence: ${(data.confidence * 100).toFixed(1)}%)`;
                    } else {
                        console.log(`Object tracking initialized with manual selection. ID: ${selectedObjectId}`);
                        document.getElementById('videoStatus').textContent = `Tracking initialized: Manual selection`;
                    }

                    // Update video source to track the selected object
                    const videoElem = document.getElementById('videoFeed');
                    const trackingEnabled = getTrackingEnabled();

                    console.log(`Selected object ID: ${selectedObjectId}, activeSource: ${activeSource}, currentVideo: ${currentVideo}`);

                    // If webcam is active
                    if (activeSource === 'webcam' && currentVideo === 'webcam') {
                        // Webcam is active, update with tracking parameter
                        videoElem.src = `/webcam_feed?tracking=${trackingEnabled}&object_id=${selectedObjectId}`;
                    }
                    // If video upload is active
                    else if (activeSource === 'video' && currentVideo && currentVideo !== 'webcam') {
                        // Update video source with tracking parameter
                        videoElem.src = `/video_feed?filename=${currentVideo}&tracking=${trackingEnabled}&object_id=${selectedObjectId}`;
                    }

                    toggleDrawingMode(); // Exit drawing mode
                } else {
                    document.getElementById('videoStatus').textContent = `Error selecting object: ${data.error}`;
                }
            } catch (error) {
                console.error('Error selecting object:', error);
                document.getElementById('videoStatus').textContent = 'Error processing selection';
            }
        });

        cancelBtn.addEventListener('click', () => {
            clearDrawing();
            toggleDrawingMode();
        });

        function uploadVideo() {
            const fileInput = document.getElementById('videoFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a video file first');
                return;
            }
            
            // Clear any previous state
            resetState();
            document.getElementById('videoStatus').textContent = 'Uploading video...';
            
            const formData = new FormData();
            formData.append('video', file);
            
            fetch('/upload_video', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentVideo = data.filename;
                    document.getElementById('videoStatus').textContent = 'Video uploaded successfully';
                    loadFirstFrame();
                    updateControlButtons();
                } else {
                    document.getElementById('videoStatus').textContent = 'Upload failed: ' + data.error;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('videoStatus').textContent = 'Upload error';
            });
        }

        function resetState() {
            // Reset all state variables
            selectedObjectId = null;
            isPlaying = false;
            currentFrameIndex = 0;
            
            // Clear canvas
            if (drawCanvas) {
                const ctx = drawCanvas.getContext('2d');
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            }
            
            // Reset any active drawing mode
            const videoSection = document.querySelector('.video-section');
            if (videoSection && videoSection.classList.contains('drawing-active')) {
                toggleDrawingMode();
            }
            
            // Clear video feed
            const videoFeed = document.getElementById('videoFeed');
            if (videoFeed) {
                videoFeed.src = '';
                videoFeed.style.display = 'none';
            }
            
            // Show placeholder
            const placeholder = document.getElementById('placeholder');
            if (placeholder) {
                placeholder.style.display = 'flex';
            }
            
            console.log("Application state has been reset");
        }

        function loadFirstFrame() {
            const videoFeed = document.getElementById('videoFeed');
            const placeholder = document.getElementById('placeholder');
            const params = new URLSearchParams();
            params.append('filename', currentVideo);
            params.append('frame', 'first');
            
            videoFeed.src = `/video_frame?${params.toString()}`;
            videoFeed.classList.add('active');
            placeholder.style.display = 'none';
            videoFeed.style.display = 'block';
        }

        function pauseVideoStream() {
            if (!currentVideo) return;
            
            // First, immediately pause the visual display by freezing the current frame
            // This creates a more responsive pause experience for the user
            const videoFeed = document.getElementById('videoFeed');
            
            // Take a snapshot of the current frame being displayed
            const canvas = document.createElement('canvas');
            canvas.width = videoFeed.width || videoFeed.offsetWidth;
            canvas.height = videoFeed.height || videoFeed.offsetHeight;
            
            // Store the current src to restore later if needed
            const originalSrc = videoFeed.src;
            
            // Update UI immediately to show paused state
            document.getElementById('videoStatus').textContent = 'Pausing video...';
            
            // Get current frame index from server 
            fetch('/current_frame_index')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Store the frame index for resuming
                        currentFrameIndex = data.frame_index;
                        console.log(`Paused at frame: ${currentFrameIndex}`);
                        
                        // Now get the high-quality current frame from server
                        const params = new URLSearchParams();
                        params.append('filename', currentVideo);
                        params.append('frame', 'current');
                        
                        // Set the image source to the high-quality current frame
                        videoFeed.src = `/video_frame?${params.toString()}`;
                        document.getElementById('videoStatus').textContent = `Video paused at frame ${currentFrameIndex}`;
                    } else {
                        // Fallback if getting the frame index fails
                        document.getElementById('videoStatus').textContent = 'Video paused';
                    }
                })
                .catch(error => {
                    console.error('Error getting frame index:', error);
                    // Fallback if the server request fails
                    document.getElementById('videoStatus').textContent = 'Video paused';
                });
        }

        function startVideoStream() {
            if (!currentVideo) return;
            
            const videoFeed = document.getElementById('videoFeed');
            const placeholder = document.getElementById('placeholder');
            const params = new URLSearchParams();
            
            // Update UI to show loading state
            document.getElementById('videoStatus').textContent = 'Loading video stream...';
            
            params.append('filename', currentVideo);
            
            // Enable tracking only when a specific object is selected
            const trackingEnabled = selectedObjectId !== null;
            params.append('tracking', trackingEnabled.toString());
            
            if (selectedObjectId !== null) {
                params.append('object_id', selectedObjectId);
                console.log(`Starting video stream with tracking for object ID: ${selectedObjectId}`);
            } else {
                console.log('Starting video stream with detection of all objects');
            }
            
            // If we're resuming from a paused state, pass the current frame index
            if (currentFrameIndex > 0) {
                params.append('start_frame', currentFrameIndex);
                console.log(`Resuming from frame: ${currentFrameIndex}`);
                
                // Update status to show resuming
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? `Resuming tracking from frame ${currentFrameIndex}...` 
                        : `Resuming detection from frame ${currentFrameIndex}...`;
            } else {
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? 'Starting object tracking...' 
                        : 'Starting object detection...';
            }
            
            const streamUrl = `/video_feed?${params.toString()}`;
            console.log(`Stream URL: ${streamUrl}`);
            
            // Set the source to the video stream
            videoFeed.src = streamUrl;
            videoFeed.classList.add('active');
            videoFeed.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Add a load event listener to update the status once the stream is active
            videoFeed.onload = function() {
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? `Tracking object ID: ${selectedObjectId}` 
                        : 'Detecting all objects...';
            };
        }

        function stopVideo() {
            if (!currentVideo) return;
            
            // For webcam, stop the webcam
            if (currentVideo === 'webcam') {
                console.log("Stopping webcam from video controls");
                stopWebcam();
                return;
            }
            
            // For regular video
            isPlaying = false;
            
            const videoElem = document.getElementById('videoFeed');
            videoElem.src = '';
            videoElem.classList.remove('active');
            document.getElementById('placeholder').style.display = 'block';
            
            // Reset tracking and selected object
            selectedObjectId = null;
            
            document.getElementById('videoStatus').textContent = 'Video stopped';
            
            updateControlButtons();
        }

        function updateControlButtons() {
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            // Enable controls if either regular video is loaded or webcam is active
            const videoActive = currentVideo !== null;
            
            playBtn.disabled = !videoActive;
            stopBtn.disabled = !videoActive;

            // Update play button icon with better SVG paths
            playBtn.innerHTML = isPlaying ? 
                '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>' : 
                '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>';
        }

        function togglePlay() {
            if (!currentVideo) return;
            
            isPlaying = !isPlaying;
            
            // For webcam mode, we use the server-side pause/resume
            if (currentVideo === 'webcam') {
                const videoElem = document.getElementById('videoFeed');
                
                if (isPlaying) {
                    console.log("Resuming webcam");
                    // Call the resume endpoint
                    fetch('/resume_webcam', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('videoStatus').textContent = 'Webcam streaming resumed';
                        } else {
                            document.getElementById('videoStatus').textContent = 'Error resuming webcam: ' + data.message;
                        }
                    })
                    .catch(error => {
                        console.error('Error resuming webcam:', error);
                        document.getElementById('videoStatus').textContent = 'Error resuming webcam';
                    });
                } else {
                    console.log("Pausing webcam");
                    // Call the pause endpoint
                    fetch('/pause_webcam', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('videoStatus').textContent = 'Webcam streaming paused';
                        } else {
                            document.getElementById('videoStatus').textContent = 'Error pausing webcam: ' + data.message;
                        }
                    })
                    .catch(error => {
                        console.error('Error pausing webcam:', error);
                        document.getElementById('videoStatus').textContent = 'Error pausing webcam';
                    });
                }
            } else {
                // Regular video
                if (isPlaying) {
                    startVideoStream();
                } else {
                    pauseVideoStream();
                }
            }
            
            updateControlButtons();
        }

        function updateVideoFeed() {
            if (!currentVideo) {
                document.getElementById('videoStatus').textContent = 'No video loaded';
                document.getElementById('placeholder').style.display = 'block';
                document.getElementById('videoFeed').style.display = 'none';
                document.getElementById('videoFeed').classList.remove('active');
                updateControlButtons();
                return;
            }

            if (isPlaying) {
                startVideoStream();
            } else {
                loadFirstFrame();
            }
        }

        async function clearSelection() {
            try {
                const response = await fetch('/clear_selection', {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    // Reset the selected object ID
                    selectedObjectId = null;
                    console.log("Cleared object selection");
                    
                    // Restart video stream without tracking
                    startVideoStream();
                    document.getElementById('videoStatus').textContent = 'Object tracking cleared';
                }
            } catch (error) {
                console.error('Error clearing selection:', error);
            }
        }

        function shutdownServer() {
            if (confirm('Are you sure you want to shutdown the server?')) {
                fetch('/shutdown')
                    .then(response => response.json())
                    .then(data => {
                        alert(data.message);
                    })
                    .catch(error => {
                        alert('Failed to shutdown server: ' + error);
                    });
            }
        }

        // Update control buttons on page load
        document.addEventListener('DOMContentLoaded', updateControlButtons);

        // Add resize event listener to handle canvas resizing
        window.addEventListener('resize', () => {
            if (isDrawingMode) {
                initializeCanvas();
            }
        });

        // Tab switching
        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            
            // Find the clicked button and activate it
            document.querySelector(`.tab-btn[onclick*="${tabId}"]`).classList.add('active');
            
            // Reset video feed if tab is changed
            const videoElem = document.getElementById('videoFeed');
            videoElem.src = '';
            videoElem.classList.remove('active');
            
            // If switching to webcam tab, load available cameras
            if (tabId === 'webcam-tab') {
                loadAvailableCameras();
                activeSource = 'webcam';
                updateCameraStatus('Not connected', false);
                document.getElementById('webcamStatus').className = 'status';
                document.getElementById('webcamStatus').textContent = 'Select and start a camera';
                document.getElementById('videoStatus').textContent = 'Webcam mode: Select and start a camera';
            } else {
                activeSource = 'video';
                document.getElementById('videoStatus').textContent = 'Upload a video file to begin analysis';
                // Stop webcam if it was running
                if (document.getElementById('stopWebcamBtn') && !document.getElementById('stopWebcamBtn').disabled) {
                    stopWebcam();
                }
            }
        }
        
        // Load available cameras
        async function loadAvailableCameras() {
            try {
                const statusElem = document.getElementById('webcamStatus');
                statusElem.textContent = 'Searching for cameras...';
                
                const response = await fetch('/get_available_cameras');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                
                const select = document.getElementById('cameraSelect');
                select.innerHTML = '';
                
                if (!data.cameras || data.cameras.length === 0) {
                    select.innerHTML = '<option value="-1">No cameras found</option>';
                    document.getElementById('startWebcamBtn').disabled = true;
                    statusElem.textContent = 'No cameras detected';
                } else {
                    data.cameras.forEach(camera => {
                        const option = document.createElement('option');
                        option.value = camera.id;
                        option.textContent = camera.name;
                        select.appendChild(option);
                    });
                    document.getElementById('startWebcamBtn').disabled = false;
                    statusElem.textContent = `Found ${data.cameras.length} camera(s)`;
                }
            } catch (error) {
                console.error('Error loading cameras:', error);
                document.getElementById('webcamStatus').textContent = 'Error detecting cameras: ' + error.message;
                
                // Add fallback option
                const select = document.getElementById('cameraSelect');
                select.innerHTML = '';
                select.innerHTML = '<option value="0">Default Camera</option>';
                document.getElementById('startWebcamBtn').disabled = false;
            }
        }
        
        // Update status indicator
        function updateCameraStatus(status, isActive = false) {
            const indicator = document.getElementById('cameraIndicator');
            const statusText = document.getElementById('cameraStatusText');
            
            if (isActive) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
            
            statusText.textContent = status;
        }
        
        // Start webcam stream
        async function startWebcam() {
            // Check if we're on AWS EC2 or other remote server
            const isRemoteServer = window.location.hostname !== 'localhost' && 
                                   window.location.hostname !== '127.0.0.1';
            
            if (isRemoteServer) {
                // Use client-side webcam capture when on remote server
                startClientWebcam();
            } else {
                // Use server-side webcam capture when local
                const cameraId = document.getElementById('cameraSelect').value;
                const statusElem = document.getElementById('webcamStatus');
                const videoStatusElem = document.getElementById('videoStatus');
                
                if (cameraId === "-1") {
                    statusElem.textContent = 'No cameras available';
                    videoStatusElem.textContent = 'No cameras available';
                    updateCameraStatus('No cameras available', false);
                    return;
                }
                
                try {
                    statusElem.textContent = 'Starting webcam...';
                    videoStatusElem.textContent = 'Starting webcam...';
                    updateCameraStatus('Connecting...', false);
                    document.getElementById('startWebcamBtn').disabled = true;
                    
                    const formData = new FormData();
                    formData.append('camera_id', cameraId);
                    
                    const response = await fetch('/start_webcam', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        statusElem.textContent = 'Webcam active: ' + data.message;
                        videoStatusElem.textContent = 'Webcam active: Ready for object detection and tracking';
                        statusElem.className = 'status success';
                        updateCameraStatus('Connected', true);
                        document.getElementById('startWebcamBtn').disabled = true;
                        document.getElementById('stopWebcamBtn').disabled = false;
                        
                        // Update video feed source
                        const videoElem = document.getElementById('videoFeed');
                        const trackingEnabled = getTrackingEnabled();
                        
                        // Show video element, hide placeholder
                        document.getElementById('placeholder').style.display = 'none';
                        videoElem.style.display = 'block';
                        
                        // Set current video to special webcam indicator
                        currentVideo = 'webcam';
                        isPlaying = true;
                        
                        // Update control buttons
                        updateControlButtons();
                        
                        // Set source to webcam feed with tracking parameters
                        const webcamUrl = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
                        console.log("Setting webcam URL to:", webcamUrl);
                        videoElem.src = webcamUrl;
                        videoElem.classList.add('active');
                        
                        // Set up error handling for video feed
                        videoElem.onerror = function() {
                            console.error("Error loading webcam feed");
                            statusElem.textContent = 'Error receiving webcam feed';
                            videoStatusElem.textContent = 'Error receiving webcam feed';
                            statusElem.className = 'status error';
                            updateCameraStatus('Error', false);
                            // Try to recover
                            retryWebcamFeed(3);
                        };
                    } else {
                        document.getElementById('startWebcamBtn').disabled = false;
                        statusElem.textContent = `Error: ${data.message}`;
                        videoStatusElem.textContent = `Error: ${data.message}`;
                        statusElem.className = 'status error';
                        updateCameraStatus('Connection failed', false);
                    }
                } catch (error) {
                    console.error('Error starting webcam:', error);
                    document.getElementById('startWebcamBtn').disabled = false;
                    statusElem.textContent = 'Failed to start webcam: ' + error.message;
                    videoStatusElem.textContent = 'Failed to start webcam: ' + error.message;
                    statusElem.className = 'status error';
                    updateCameraStatus('Connection failed', false);
                }
            }
        }
        
        // Retry webcam feed if it fails
        async function retryWebcamFeed(retriesLeft) {
            if (retriesLeft <= 0) {
                document.getElementById('webcamStatus').textContent = 'Could not connect to webcam after retries';
                document.getElementById('videoStatus').textContent = 'Could not connect to webcam after multiple attempts';
                document.getElementById('startWebcamBtn').disabled = false;
                document.getElementById('stopWebcamBtn').disabled = true;
                return;
            }
            
            console.log(`Retrying webcam feed, ${retriesLeft} attempts left`);
            document.getElementById('videoStatus').textContent = `Reconnecting to webcam (${retriesLeft} attempts left)...`;
            
            // Wait a moment before retry
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const videoElem = document.getElementById('videoFeed');
            const trackingEnabled = getTrackingEnabled();
            
            // Add timestamp to URL to prevent caching
            const timestamp = new Date().getTime();
            videoElem.src = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}&t=${timestamp}`;
            
            videoElem.onerror = function() {
                retryWebcamFeed(retriesLeft - 1);
            };
        }
        
        // Stop webcam stream
        async function stopWebcam() {
            // Check if we're using client-side webcam
            if (isClientWebcamActive) {
                stopClientWebcam();
            } else {
                // Use original server-side webcam stop
                const statusElem = document.getElementById('webcamStatus');
                const videoStatusElem = document.getElementById('videoStatus');
                
                try {
                    statusElem.textContent = 'Stopping webcam...';
                    videoStatusElem.textContent = 'Stopping webcam...';
                    statusElem.className = 'status';
                    updateCameraStatus('Disconnecting...', false);
                    
                    const response = await fetch('/stop_webcam', {
                        method: 'POST'
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        statusElem.textContent = 'Webcam stopped';
                        videoStatusElem.textContent = 'Webcam stopped';
                        statusElem.className = 'status';
                        updateCameraStatus('Disconnected', false);
                        document.getElementById('startWebcamBtn').disabled = false;
                        document.getElementById('stopWebcamBtn').disabled = true;
                        
                        // Hide video feed
                        const videoElem = document.getElementById('videoFeed');
                        videoElem.src = '';
                        videoElem.classList.remove('active');
                        
                        // Reset video state
                        currentVideo = null;
                        isPlaying = false;
                        updateControlButtons();
                        
                        // Show placeholder
                        document.getElementById('placeholder').style.display = 'block';
                        videoElem.style.display = 'none';
                        
                        // Reset selected object
                        selectedObjectId = null;
                    } else {
                        statusElem.textContent = `Error: ${data.message}`;
                        videoStatusElem.textContent = `Error: ${data.message}`;
                        statusElem.className = 'status warning';
                    }
                } catch (error) {
                    console.error('Error stopping webcam:', error);
                    statusElem.textContent = 'Failed to stop webcam: ' + error.message;
                    videoStatusElem.textContent = 'Failed to stop webcam: ' + error.message;
                    statusElem.className = 'status error';
                }
            }
        }

        // Get tracking state based on current source
        function getTrackingEnabled() {
            if (activeSource === 'webcam') {
                return document.getElementById('webcamTrackingToggle').checked;
            } else {
                return true; // Always enabled for video mode
            }
        }

        // Toggle webcam tracking
        function toggleWebcamTracking() {
            // Only applies to webcam mode
            if (activeSource === 'webcam' && currentVideo === 'webcam') {
                const trackingEnabled = document.getElementById('webcamTrackingToggle').checked;
                const videoElem = document.getElementById('videoFeed');
                
                console.log("Updating webcam feed with tracking:", trackingEnabled);
                
                // Update status text
                if (trackingEnabled) {
                    document.getElementById('videoStatus').textContent = selectedObjectId 
                        ? `Tracking object ID: ${selectedObjectId}` 
                        : 'Detecting all objects...';
                } else {
                    document.getElementById('videoStatus').textContent = 'Webcam streaming (tracking disabled)';
                }
                
                // Webcam is active, update with tracking parameter
                videoElem.src = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
            }
        }

        // Set up object tracking by ID
        function trackObject(objectId) {
            // If objectId is not provided, try to get it from the input element
            if (!objectId) {
                const objectIdInput = document.getElementById('objectId');
                if (objectIdInput) {
                    objectId = objectIdInput.value;
                }
            }
            
            // Validate we have an object ID
            if (!objectId) {
                document.getElementById('videoStatus').textContent = 'Please specify an object ID to track';
                return;
            }
            
            selectedObjectId = objectId;
            const videoElem = document.getElementById('videoFeed');
            const trackingEnabled = getTrackingEnabled();
            
            console.log(`Tracking object ID: ${objectId}, activeSource: ${activeSource}, currentVideo: ${currentVideo}`);
            
            // Update status text
            document.getElementById('videoStatus').textContent = `Tracking object ID: ${objectId}`;
            
            // If webcam is active
            if (activeSource === 'webcam' && currentVideo === 'webcam') {
                videoElem.src = `/webcam_feed?tracking=${trackingEnabled}&object_id=${objectId}`;
            } 
            // If video upload is active
            else if (activeSource === 'video' && currentVideo && currentVideo !== 'webcam') {
                videoElem.src = `/video_feed?filename=${currentVideo}&tracking=${trackingEnabled}&object_id=${objectId}`;
            }
        }

        async function startClientWebcam() {
            try {
                const cameraId = document.getElementById('cameraSelect').value;
                const statusElem = document.getElementById('webcamStatus');
                const videoStatusElem = document.getElementById('videoStatus');
                
                statusElem.textContent = 'Starting client-side webcam...';
                videoStatusElem.textContent = 'Starting client-side webcam...';
                updateCameraStatus('Connecting...', false);
                
                // Get user media from browser
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                // Try to get the stream
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                clientWebcamStream = stream;
                
                // Set up video element
                const video = document.getElementById('clientWebcam');
                video.srcObject = stream;
                
                // Set up canvas for frame capture
                const canvas = document.getElementById('clientCanvas');
                canvas.width = 1280;
                canvas.height = 720;
                
                // Mark webcam as active
                isClientWebcamActive = true;
                
                // Start sending frames to server
                clientWebcamInterval = setInterval(captureAndSendFrame, 100); // 10 FPS
                
                // Update UI
                statusElem.textContent = 'Client webcam active';
                videoStatusElem.textContent = 'Client webcam active: Ready for object detection and tracking';
                statusElem.className = 'status success';
                updateCameraStatus('Connected', true);
                document.getElementById('startWebcamBtn').disabled = true;
                document.getElementById('stopWebcamBtn').disabled = false;
                
                // Show video element, hide placeholder
                document.getElementById('placeholder').style.display = 'none';
                document.getElementById('videoFeed').style.display = 'block';
                
                // Set current video to special webcam indicator
                currentVideo = 'webcam';
                isPlaying = true;
                
                // Update control buttons
                updateControlButtons();
                
                // Set source to webcam feed with tracking parameters
                const trackingEnabled = getTrackingEnabled();
                const webcamUrl = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
                console.log("Setting webcam URL to:", webcamUrl);
                document.getElementById('videoFeed').src = webcamUrl;
                document.getElementById('videoFeed').classList.add('active');
            } catch (error) {
                console.error('Error starting client webcam:', error);
                statusElem.textContent = 'Error starting client webcam: ' + error.message;
                updateCameraStatus('Error', false);
            }
        }

        async function stopClientWebcam() {
            if (clientWebcamStream) {
                // Stop sending frames
                if (clientWebcamInterval) {
                    clearInterval(clientWebcamInterval);
                    clientWebcamInterval = null;
                }
                
                // Stop all tracks in the stream
                clientWebcamStream.getTracks().forEach(track => track.stop());
                clientWebcamStream = null;
                isClientWebcamActive = false;
                
                // Tell server to stop webcam
                await fetch('/stop_webcam', { method: 'POST' });
                
                // Update UI
                const statusElem = document.getElementById('webcamStatus');
                statusElem.textContent = 'Client webcam stopped';
                statusElem.className = 'status';
                updateCameraStatus('Not connected', false);
                document.getElementById('startWebcamBtn').disabled = false;
                document.getElementById('stopWebcamBtn').disabled = true;
            }
        }

        async function captureAndSendFrame() {
            if (!isClientWebcamActive || !clientWebcamStream) return;
            
            const video = document.getElementById('clientWebcam');
            const canvas = document.getElementById('clientCanvas');
            const ctx = canvas.getContext('2d');
            
            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convert canvas to blob
            canvas.toBlob(async (blob) => {
                // Create form data
                const formData = new FormData();
                formData.append('frame_data', blob, 'frame.jpg');
                
                // Send to server
                try {
                    await fetch('/webcam_frame_upload', {
                        method: 'POST',
                        body: formData
                    });
                } catch (error) {
                    console.error('Error sending frame to server:', error);
                }
            }, 'image/jpeg', 0.85); // JPEG at 85% quality
        }
    </script>
  </body>
</html>
