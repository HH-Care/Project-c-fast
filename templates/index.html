<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Real-time Object Tracking</title>
    <style>
        :root {
            --military-dark: #1a1f1c;
            --military-green: #4b5320;
            --accent-green: #87a330;
            --gunmetal: #2a3439;
            --light-gray: #c4c8c5;
            --tactical-red: #a33030;
            --border-radius: 6px;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: 'Roboto', sans-serif;
            background: var(--military-dark);
            color: var(--light-gray);
            min-height: 100vh;
            background-image: 
                linear-gradient(45deg, rgba(43, 48, 43, 0.1) 25%, transparent 25%),
                linear-gradient(-45deg, rgba(43, 48, 43, 0.1) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, rgba(43, 48, 43, 0.1) 75%),
                linear-gradient(-45deg, transparent 75%, rgba(43, 48, 43, 0.1) 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .config-panel {
            width: 300px;
            background: var(--gunmetal);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .section {
            margin-bottom: 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .section-title {
            color: var(--accent-green);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--military-green);
            padding-bottom: 8px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--light-gray);
        }

        .form-group input[type="file"] {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
            margin-bottom: 10px;
        }

        button {
            background: var(--military-green);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            width: 100%;
        }

        button:hover {
            background: var(--accent-green);
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(1px);
        }

        button.danger {
            background: var(--tactical-red);
        }

        button.danger:hover {
            background: #bf3a3a;
        }

        .help-text {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 8px;
        }

        .status {
            font-size: 14px;
            color: var(--light-gray);
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: var(--border-radius);
            border-left: 3px solid var(--military-green);
        }

        .status.error {
            border-left: 3px solid var(--tactical-red);
        }

        .status.success {
            border-left: 3px solid var(--accent-green);
        }

        .status.warning {
            border-left: 3px solid #e9c46a;
        }

        /* Camera status indicator */
        .camera-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #555;
        }

        .camera-indicator.active {
            background-color: var(--accent-green);
            box-shadow: 0 0 8px var(--accent-green);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .video-container {
            flex: 1;
            background: var(--gunmetal);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-section {
            background: var(--military-dark);
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
            aspect-ratio: 16/9;
            border: 1px solid var(--military-green);
        }

        #videoFeed {
            width: 100%;
            height: 100%;
            object-fit: contain;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: block;
        }

        #videoFeed.active {
            opacity: 1;
        }

        #drawCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            display: none;
            z-index: 3;
        }

        .drawing-active #drawCanvas {
            display: block !important;
        }

        .drawing-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 4;
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid var(--military-green);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .drawing-active .drawing-controls {
            opacity: 1;
            pointer-events: auto;
        }

        .drawing-btn {
            background: var(--military-green);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            min-width: 120px;
            display: none;
            opacity: 0;
            transform: translateY(10px);
        }

        /* Fix for config panel buttons */
        .section .drawing-btn {
            display: block;
            opacity: 1;
            transform: none;
        }

        .drawing-active .drawing-btn {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .drawing-btn:hover {
            background: var(--accent-green);
            transform: translateY(-2px);
        }

        .drawing-btn.active {
            background: var(--accent-green);
            box-shadow: 0 0 10px rgba(135, 163, 48, 0.3);
        }

        .drawing-btn.secondary {
            background: var(--gunmetal);
        }

        .drawing-btn.secondary:hover {
            background: var(--military-green);
        }

        #confirmDrawBtn {
            background: var(--military-green);
            transition: all 0.3s ease;
        }

        #confirmDrawBtn.active {
            background: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
        }

        .playback-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 4;
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid var(--military-green);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .control-btn {
            background: var(--military-green);
            border: none;
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            padding: 0;
        }

        .control-btn:hover {
            background: var(--accent-green);
            transform: scale(1.1);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .control-btn svg {
            width: 28px;
            height: 28px;
            fill: currentColor;
            stroke: currentColor;
            stroke-width: 1;
        }

        .placeholder-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--light-gray);
        }

        .placeholder-logo {
            width: 100px;
            height: 100px;
            background: var(--military-green);
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            border: 3px solid var(--accent-green);
            box-shadow: 0 0 20px rgba(135, 163, 48, 0.2);
        }

        .select-input {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tab-btn {
            background: var(--gunmetal);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn.active {
            background: var(--military-green);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .checkbox-wrapper input[type="checkbox"] {
            margin-right: 8px;
        }

        .camera-status {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }

        /* Fix logo size */
        .logo-section img {
            max-width: 100px;
            height: auto;
            margin-bottom: 10px;
        }

        .logo-section h1 {
            font-size: 1.2em;
            margin: 5px 0;
        }

        .input-with-button {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .input-with-button input {
            flex: 1;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--military-green);
            border-radius: var(--border-radius);
            color: var(--light-gray);
        }
    </style>
  </head>
  <body>
    <div class="container">
        <!-- Left Configuration Panel -->
        <div class="config-panel">
            <!-- Logo Section -->
            <div class="logo-section">
                <img src="/static/images/logo.png" alt="System Logo">
                <h1> Real-time Object Tracking</h1>
                <p>Advanced AI-Powered Detection System</p>
            </div>

            <div class="section">
                <div class="section-title">Video Source</div>
                <div class="tabs">
                    <button class="tab-btn active" onclick="switchTab('upload-tab')">Upload Video</button>
                    <button class="tab-btn" onclick="switchTab('webcam-tab')">Webcam</button>
                </div>
                
                <!-- Video Upload Tab (existing functionality) -->
                <div id="upload-tab" class="tab-content active">
                    <div class="form-group">
                        <label for="videoFile">Upload Video File</label>
                        <input type="file" id="videoFile" accept="video/*">
                        <button onclick="uploadVideo()">Upload Video</button>
                        <div id="uploadStatus" class="status"></div>
                    </div>
                </div>
                
                <!-- Webcam Tab (new functionality) -->
                <div id="webcam-tab" class="tab-content">
                    <div class="form-group">
                        <label for="cameraSelect">Select Local Camera</label>
                        <select id="cameraSelect" class="select-input">
                            <option value="0">Loading cameras...</option>
                        </select>
                    </div>
                    
                    <!-- Browser Camera Access -->
                    <div class="form-group">
                        <label for="browserCamera">Use Browser Camera (Cloud-friendly)</label>
                        <button onclick="accessBrowserCamera()" class="select-input">Start Browser Camera</button>
                        <div class="help-text">Uses your device's camera instead of server camera - ideal for AWS EC2</div>
                    </div>
                    
                    <div class="form-group">
                        <div class="camera-status">
                            <span class="camera-indicator" id="cameraIndicator"></span>
                            Camera Status: <span id="cameraStatusText">Not connected</span>
                        </div>
                        <div class="button-group">
                            <button id="startWebcamBtn" onclick="startWebcam()">Start Local Camera</button>
                            <button id="stopWebcamBtn" onclick="stopWebcam()" disabled>Stop Camera</button>
                        </div>
                        <div id="webcamStatus" class="status"></div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-wrapper">
                            <input type="checkbox" id="webcamTrackingToggle" checked onchange="toggleWebcamTracking()">
                            <label for="webcamTrackingToggle">Enable Tracking</label>
                        </div>
                        <div class="help-text">Toggle real-time tracking of objects</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">Drawing Controls</div>
                <button id="drawModeBtn" style="display: block; background: var(--military-green); color: white; text-transform: uppercase;" onclick="toggleDrawingMode()">Enable Drawing Mode</button>
                <button onclick="clearSelection()" style="display: block; margin-top: 10px; background: var(--gunmetal); color: white; text-transform: uppercase;">Clear Selection</button>
                <div class="help-text">Draw a box around the object you want to track</div>
            </div>

            <div class="section">
                <div class="section-title">Server Controls</div>
                <div class="form-group">
                    <button class="danger" onclick="shutdownServer()">Shutdown Server</button>
                    <div class="help-text">Safely stop the server and clean up resources</div>
                </div>
            </div>
        </div>

        <!-- Right Video Display -->
    <div class="video-container">
            <div class="video-section">
                <img id="videoFeed" src="" alt="Video Feed">
                <canvas id="drawCanvas"></canvas>
                <div class="drawing-controls">
                    <button id="confirmDrawBtn" style="display: block; min-width: 120px; margin: 0; padding: 8px 16px; font-size: 14px;">Confirm Selection</button>
                    <button id="cancelDrawBtn" class="secondary" style="display: block; min-width: 120px; margin: 0; padding: 8px 16px; font-size: 14px;">Cancel</button>
                </div>
                <div id="placeholder" class="placeholder-content">
                    <div class="placeholder-logo"></div>
                    <h2> Real-time Tracking</h2>
                    <p>Upload a video to begin analysis</p>
                </div>
                <div class="playback-controls">
                    <button class="control-btn" id="playBtn" onclick="togglePlay()" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                        </svg>
                    </button>
                    <button class="control-btn" id="stopBtn" onclick="stopVideo()" disabled>
                        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M6 6h12v12H6z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div id="videoStatus" class="status">No video loaded</div>
    </div>
    </div>

    <script>
        let currentVideo = null;
        let selectedObjectId = null;
        let isPlaying = false;
        let videoStream = null;
        let currentFrameIndex = 0;
        let isDrawingMode = false;
        let isDrawing = false;
        let startX, startY;
        let currentRect = null;
        let activeSource = 'video'; // 'video' or 'webcam'

        const videoFeed = document.getElementById('videoFeed');
        const drawCanvas = document.getElementById('drawCanvas');
        const confirmBtn = document.getElementById('confirmDrawBtn');
        const cancelBtn = document.getElementById('cancelDrawBtn');
        const ctx = drawCanvas.getContext('2d');

        function initializeCanvas() {
            drawCanvas.width = videoFeed.offsetWidth;
            drawCanvas.height = videoFeed.offsetHeight;
        }

        function setupDrawingListeners() {
            drawCanvas.addEventListener('mousedown', startDrawing);
            drawCanvas.addEventListener('mousemove', draw);
            drawCanvas.addEventListener('mouseup', endDrawing);
            drawCanvas.addEventListener('mouseout', endDrawing);
        }

        function startDrawing(e) {
            isDrawing = true;
            const rect = drawCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
            currentRect = {
                x: startX,
                y: startY,
                width: 0,
                height: 0
            };
        }

        function draw(e) {
            if (!isDrawing) return;
            const rect = drawCanvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            currentRect.width = currentX - startX;
            currentRect.height = currentY - startY;

            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
        }

        function endDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            if (currentRect) {
                confirmBtn.classList.add('active');
            }
        }

        function clearDrawing() {
            ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            currentRect = null;
            confirmBtn.classList.remove('active');
        }

        function toggleDrawingMode() {
            // Don't enter drawing mode if no video is loaded or webcam isn't started
            if ((!currentVideo && activeSource === 'video') || 
                (activeSource === 'webcam' && !document.getElementById('stopWebcamBtn').disabled === false)) {
                document.getElementById('videoStatus').textContent = 'Please load a video or start the webcam first';
                return;
            }
            
            isDrawingMode = !isDrawingMode;
            const videoSection = document.querySelector('.video-section');
            const drawModeBtn = document.getElementById('drawModeBtn');
            const drawCanvas = document.getElementById('drawCanvas');
            const drawingControls = document.querySelector('.drawing-controls');
            
            console.log("Drawing mode toggled:", isDrawingMode);
            
            if (isDrawingMode) {
                document.getElementById('videoStatus').textContent = 'Drawing mode: Select an object to track';
                videoSection.classList.add('drawing-active');
                drawModeBtn.classList.add('active');
                drawModeBtn.textContent = 'Drawing Mode Active';
                drawCanvas.style.display = 'block';
                drawingControls.style.opacity = '1';
                drawingControls.style.pointerEvents = 'auto';
                initializeCanvas();
                setupDrawingListeners();
                console.log("Added drawing-active class");
            } else {
                if (activeSource === 'webcam') {
                    document.getElementById('videoStatus').textContent = 'Webcam streaming active';
                } else {
                    document.getElementById('videoStatus').textContent = 'Video playback active';
                }
                videoSection.classList.remove('drawing-active');
                drawModeBtn.classList.remove('active');
                drawModeBtn.textContent = 'Enable Drawing Mode';
                drawCanvas.style.display = 'none';
                drawingControls.style.opacity = '0';
                drawingControls.style.pointerEvents = 'none';
                clearDrawing();
                console.log("Removed drawing-active class");
            }
        }

        confirmBtn.addEventListener('click', async () => {
            if (!currentRect) return;
            
            const rect = {
                bbox: {
                    x: currentRect.x / drawCanvas.width,
                    y: currentRect.y / drawCanvas.height,
                    width: Math.abs(currentRect.width) / drawCanvas.width,
                    height: Math.abs(currentRect.height) / drawCanvas.height
                }
            };

            document.getElementById('videoStatus').textContent = 'Processing selection...';

            try {
                const response = await fetch('/select_object', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(rect)
                });

                const data = await response.json();
                if (data.success) {
                    selectedObjectId = data.selected_id;
                    
                    if (data.method === "detector_refined") {
                        console.log(`Object tracking initialized with detector refinement. ID: ${selectedObjectId}, Confidence: ${(data.confidence * 100).toFixed(1)}%, IoU: ${(data.iou * 100).toFixed(1)}%`);
                        document.getElementById('videoStatus').textContent = `Tracking initialized: Detector refined selection (Confidence: ${(data.confidence * 100).toFixed(1)}%)`;
                    } else {
                        console.log(`Object tracking initialized with manual selection. ID: ${selectedObjectId}`);
                        document.getElementById('videoStatus').textContent = `Tracking initialized: Manual selection`;
                    }

                    // Update video source to track the selected object
                    const videoElem = document.getElementById('videoFeed');
                    const trackingEnabled = getTrackingEnabled();

                    console.log(`Selected object ID: ${selectedObjectId}, activeSource: ${activeSource}, currentVideo: ${currentVideo}`);

                    // If webcam is active
                    if (activeSource === 'webcam' && currentVideo === 'webcam') {
                        // Webcam is active, update with tracking parameter
                        videoElem.src = `/webcam_feed?tracking=${trackingEnabled}&object_id=${selectedObjectId}`;
                    }
                    // If video upload is active
                    else if (activeSource === 'video' && currentVideo && currentVideo !== 'webcam') {
                        // Update video source with tracking parameter
                        videoElem.src = `/video_feed?filename=${currentVideo}&tracking=${trackingEnabled}&object_id=${selectedObjectId}`;
                    }

                    toggleDrawingMode(); // Exit drawing mode
                } else {
                    document.getElementById('videoStatus').textContent = `Error selecting object: ${data.error}`;
                }
            } catch (error) {
                console.error('Error selecting object:', error);
                document.getElementById('videoStatus').textContent = 'Error processing selection';
            }
        });

        cancelBtn.addEventListener('click', () => {
            clearDrawing();
            toggleDrawingMode();
        });

        function uploadVideo() {
            const fileInput = document.getElementById('videoFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a video file first');
                return;
            }
            
            // Clear any previous state
            resetState();
            document.getElementById('videoStatus').textContent = 'Uploading video...';
            
            const formData = new FormData();
            formData.append('video', file);
            
            fetch('/upload_video', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    currentVideo = data.filename;
                    document.getElementById('videoStatus').textContent = 'Video uploaded successfully';
                    loadFirstFrame();
                    updateControlButtons();
                } else {
                    document.getElementById('videoStatus').textContent = 'Upload failed: ' + data.error;
                }
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('videoStatus').textContent = 'Upload error';
            });
        }

        function resetState() {
            // Reset all state variables
            selectedObjectId = null;
            isPlaying = false;
            currentFrameIndex = 0;
            
            // Clear canvas
            if (drawCanvas) {
                const ctx = drawCanvas.getContext('2d');
                ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            }
            
            // Reset any active drawing mode
            const videoSection = document.querySelector('.video-section');
            if (videoSection && videoSection.classList.contains('drawing-active')) {
                toggleDrawingMode();
            }
            
            // Clear video feed
            const videoFeed = document.getElementById('videoFeed');
            if (videoFeed) {
                videoFeed.src = '';
                videoFeed.style.display = 'none';
            }
            
            // Show placeholder
            const placeholder = document.getElementById('placeholder');
            if (placeholder) {
                placeholder.style.display = 'flex';
            }
            
            console.log("Application state has been reset");
        }

        function loadFirstFrame() {
            const videoFeed = document.getElementById('videoFeed');
            const placeholder = document.getElementById('placeholder');
            const params = new URLSearchParams();
            params.append('filename', currentVideo);
            params.append('frame', 'first');
            
            videoFeed.src = `/video_frame?${params.toString()}`;
            videoFeed.classList.add('active');
            placeholder.style.display = 'none';
            videoFeed.style.display = 'block';
        }

        function pauseVideoStream() {
            if (!currentVideo) return;
            
            // First, immediately pause the visual display by freezing the current frame
            // This creates a more responsive pause experience for the user
            const videoFeed = document.getElementById('videoFeed');
            
            // Take a snapshot of the current frame being displayed
            const canvas = document.createElement('canvas');
            canvas.width = videoFeed.width || videoFeed.offsetWidth;
            canvas.height = videoFeed.height || videoFeed.offsetHeight;
            
            // Store the current src to restore later if needed
            const originalSrc = videoFeed.src;
            
            // Update UI immediately to show paused state
            document.getElementById('videoStatus').textContent = 'Pausing video...';
            
            // Get current frame index from server 
            fetch('/current_frame_index')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Store the frame index for resuming
                        currentFrameIndex = data.frame_index;
                        console.log(`Paused at frame: ${currentFrameIndex}`);
                        
                        // Now get the high-quality current frame from server
                        const params = new URLSearchParams();
                        params.append('filename', currentVideo);
                        params.append('frame', 'current');
                        
                        // Set the image source to the high-quality current frame
                        videoFeed.src = `/video_frame?${params.toString()}`;
                        document.getElementById('videoStatus').textContent = `Video paused at frame ${currentFrameIndex}`;
                    } else {
                        // Fallback if getting the frame index fails
                        document.getElementById('videoStatus').textContent = 'Video paused';
                    }
                })
                .catch(error => {
                    console.error('Error getting frame index:', error);
                    // Fallback if the server request fails
                    document.getElementById('videoStatus').textContent = 'Video paused';
                });
        }

        function startVideoStream() {
            if (!currentVideo) return;
            
            const videoFeed = document.getElementById('videoFeed');
            const placeholder = document.getElementById('placeholder');
            const params = new URLSearchParams();
            
            // Update UI to show loading state
            document.getElementById('videoStatus').textContent = 'Loading video stream...';
            
            params.append('filename', currentVideo);
            
            // Enable tracking only when a specific object is selected
            const trackingEnabled = selectedObjectId !== null;
            params.append('tracking', trackingEnabled.toString());
            
            if (selectedObjectId !== null) {
                params.append('object_id', selectedObjectId);
                console.log(`Starting video stream with tracking for object ID: ${selectedObjectId}`);
            } else {
                console.log('Starting video stream with detection of all objects');
            }
            
            // If we're resuming from a paused state, pass the current frame index
            if (currentFrameIndex > 0) {
                params.append('start_frame', currentFrameIndex);
                console.log(`Resuming from frame: ${currentFrameIndex}`);
                
                // Update status to show resuming
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? `Resuming tracking from frame ${currentFrameIndex}...` 
                        : `Resuming detection from frame ${currentFrameIndex}...`;
            } else {
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? 'Starting object tracking...' 
                        : 'Starting object detection...';
            }
            
            const streamUrl = `/video_feed?${params.toString()}`;
            console.log(`Stream URL: ${streamUrl}`);
            
            // Set the source to the video stream
            videoFeed.src = streamUrl;
            videoFeed.classList.add('active');
            videoFeed.style.display = 'block';
            placeholder.style.display = 'none';
            
            // Add a load event listener to update the status once the stream is active
            videoFeed.onload = function() {
                document.getElementById('videoStatus').textContent = 
                    selectedObjectId !== null 
                        ? `Tracking object ID: ${selectedObjectId}` 
                        : 'Detecting all objects...';
            };
        }

        function stopVideo() {
            if (!currentVideo) return;
            
            // For webcam, stop the webcam
            if (currentVideo === 'webcam') {
                console.log("Stopping webcam from video controls");
                stopWebcam();
                return;
            }
            
            // For regular video
            isPlaying = false;
            
            const videoElem = document.getElementById('videoFeed');
            videoElem.src = '';
            videoElem.classList.remove('active');
            document.getElementById('placeholder').style.display = 'block';
            
            // Reset tracking and selected object
            selectedObjectId = null;
            
            document.getElementById('videoStatus').textContent = 'Video stopped';
            
            updateControlButtons();
        }

        function updateControlButtons() {
            const playBtn = document.getElementById('playBtn');
            const stopBtn = document.getElementById('stopBtn');
            
            // Enable controls if either regular video is loaded or webcam is active
            const videoActive = currentVideo !== null;
            
            playBtn.disabled = !videoActive;
            stopBtn.disabled = !videoActive;

            // Update play button icon with better SVG paths
            playBtn.innerHTML = isPlaying ? 
                '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/></svg>' : 
                '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7z"/></svg>';
        }

        function togglePlay() {
            if (!currentVideo) return;
            
            isPlaying = !isPlaying;
            
            // For webcam mode, we use the server-side pause/resume
            if (currentVideo === 'webcam') {
                const videoElem = document.getElementById('videoFeed');
                
                if (isPlaying) {
                    console.log("Resuming webcam");
                    
                    // Handle browser camera specifically
                    if (window.frameCapture) {
                        // Pause frame capture for browser camera
                        clearInterval(window.frameCapture);
                        window.frameCapture = null;
                    }
                    
                    // Call the resume endpoint
                    fetch('/resume_webcam', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('videoStatus').textContent = 'Webcam streaming resumed';
                        } else {
                            document.getElementById('videoStatus').textContent = 'Error resuming webcam: ' + data.message;
                        }
                    })
                    .catch(error => {
                        console.error('Error resuming webcam:', error);
                        document.getElementById('videoStatus').textContent = 'Error resuming webcam';
                    });
                } else {
                    console.log("Pausing webcam");
                    
                    // Handle browser camera specifically
                    if (window.frameCapture) {
                        // Pause frame capture for browser camera
                        clearInterval(window.frameCapture);
                        window.frameCapture = null;
                    }
                    
                    // Call the pause endpoint
                    fetch('/pause_webcam', {
                        method: 'POST'
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            document.getElementById('videoStatus').textContent = 'Webcam streaming paused';
                        } else {
                            document.getElementById('videoStatus').textContent = 'Error pausing webcam: ' + data.message;
                        }
                    })
                    .catch(error => {
                        console.error('Error pausing webcam:', error);
                        document.getElementById('videoStatus').textContent = 'Error pausing webcam';
                    });
                }
            } else {
                // Regular video
                if (isPlaying) {
                    startVideoStream();
                } else {
                    pauseVideoStream();
                }
            }
            
            updateControlButtons();
        }

        function updateVideoFeed() {
            if (!currentVideo) {
                document.getElementById('videoStatus').textContent = 'No video loaded';
                document.getElementById('placeholder').style.display = 'block';
                document.getElementById('videoFeed').style.display = 'none';
                document.getElementById('videoFeed').classList.remove('active');
                updateControlButtons();
                return;
            }

            if (isPlaying) {
                startVideoStream();
            } else {
                loadFirstFrame();
            }
        }

        async function clearSelection() {
            try {
                const response = await fetch('/clear_selection', {
                    method: 'POST'
                });
                const data = await response.json();
                if (data.success) {
                    // Reset the selected object ID
                    selectedObjectId = null;
                    console.log("Cleared object selection");
                    
                    // Restart video stream without tracking
                    startVideoStream();
                    document.getElementById('videoStatus').textContent = 'Object tracking cleared';
                }
            } catch (error) {
                console.error('Error clearing selection:', error);
            }
        }

        function shutdownServer() {
            if (confirm('Are you sure you want to shutdown the server?')) {
                fetch('/shutdown')
                    .then(response => response.json())
                    .then(data => {
                        alert(data.message);
                    })
                    .catch(error => {
                        alert('Failed to shutdown server: ' + error);
                    });
            }
        }

        // Update control buttons on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Check browser compatibility
            checkBrowserCompatibility();
            
            // Update control buttons
            updateControlButtons();
        });

        // Function to check browser compatibility
        function checkBrowserCompatibility() {
            // Check for browser camera support
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            const hasCanvasToBlob = !!(window.HTMLCanvasElement && HTMLCanvasElement.prototype.toBlob);
            
            // If running in a non-secure context, getUserMedia may be blocked
            const isSecureContext = window.isSecureContext;
            
            // Log compatibility info
            console.log("Browser compatibility check:");
            console.log("- getUserMedia API:", hasGetUserMedia ? "✓ Available" : "✗ Not Available");
            console.log("- Canvas to Blob:", hasCanvasToBlob ? "✓ Available" : "✗ Not Available");
            console.log("- Secure Context:", isSecureContext ? "✓ Yes" : "✗ No (camera may be blocked)");
            
            // Update UI based on compatibility
            if (!hasGetUserMedia) {
                const browserCamButton = document.querySelector('button[onclick="accessBrowserCamera()"]');
                if (browserCamButton) {
                    browserCamButton.disabled = true;
                    browserCamButton.title = "Your browser doesn't support camera access";
                    browserCamButton.innerHTML = "Browser Camera Not Supported";
                }
            }
            
            // Warn user if not in secure context
            if (!isSecureContext) {
                console.warn("Application is not running in a secure context (HTTPS). Camera access may be blocked.");
            }
        }

        // Tab switching
        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabId).classList.add('active');
            
            // Find the clicked button and activate it
            document.querySelector(`.tab-btn[onclick*="${tabId}"]`).classList.add('active');
            
            // Reset video feed if tab is changed
            const videoElem = document.getElementById('videoFeed');
            videoElem.src = '';
            videoElem.classList.remove('active');
            
            // If switching to webcam tab, load available cameras
            if (tabId === 'webcam-tab') {
                loadAvailableCameras();
                activeSource = 'webcam';
                updateCameraStatus('Not connected', false);
                document.getElementById('webcamStatus').className = 'status';
                document.getElementById('webcamStatus').textContent = 'Select and start a camera';
                document.getElementById('videoStatus').textContent = 'Webcam mode: Select and start a camera';
            } else {
                activeSource = 'video';
                document.getElementById('videoStatus').textContent = 'Upload a video file to begin analysis';
                // Stop webcam if it was running
                if (document.getElementById('stopWebcamBtn') && !document.getElementById('stopWebcamBtn').disabled) {
                    stopWebcam();
                }
            }
        }
        
        // Load available cameras
        async function loadAvailableCameras() {
            try {
                const statusElem = document.getElementById('webcamStatus');
                statusElem.textContent = 'Searching for cameras...';
                
                const response = await fetch('/get_available_cameras');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                
                const select = document.getElementById('cameraSelect');
                select.innerHTML = '';
                
                if (!data.cameras || data.cameras.length === 0) {
                    select.innerHTML = '<option value="-1">No cameras found</option>';
                    document.getElementById('startWebcamBtn').disabled = true;
                    statusElem.textContent = 'No cameras detected';
                } else {
                    data.cameras.forEach(camera => {
                        const option = document.createElement('option');
                        option.value = camera.id;
                        option.textContent = camera.name;
                        select.appendChild(option);
                    });
                    document.getElementById('startWebcamBtn').disabled = false;
                    statusElem.textContent = `Found ${data.cameras.length} camera(s)`;
                }
            } catch (error) {
                console.error('Error loading cameras:', error);
                document.getElementById('webcamStatus').textContent = 'Error detecting cameras: ' + error.message;
                
                // Add fallback option
                const select = document.getElementById('cameraSelect');
                select.innerHTML = '';
                select.innerHTML = '<option value="0">Default Camera</option>';
                document.getElementById('startWebcamBtn').disabled = false;
            }
        }
        
        // Update status indicator
        function updateCameraStatus(status, isActive = false) {
            const indicator = document.getElementById('cameraIndicator');
            const statusText = document.getElementById('cameraStatusText');
            
            if (isActive) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
            
            statusText.textContent = status;
        }
        
        // Start webcam stream
        async function startWebcam() {
            const cameraId = document.getElementById('cameraSelect').value;
            const statusElem = document.getElementById('webcamStatus');
            const videoStatusElem = document.getElementById('videoStatus');

            if (cameraId === "-1") {
                statusElem.textContent = 'No cameras available, try browser camera instead';
                videoStatusElem.textContent = 'No cameras available, try browser camera instead';
                updateCameraStatus('No camera selected', false);
                return;
            }

            // Special handling for browser camera
            if (cameraId === "browser") {
                startBrowserCamera();
                return;
            }

            try {
                statusElem.textContent = 'Starting local camera...';
                videoStatusElem.textContent = 'Starting local camera...';
                updateCameraStatus('Connecting...', false);
                document.getElementById('startWebcamBtn').disabled = true;

                const formData = new FormData();
                formData.append('camera_id', cameraId);

                const response = await fetch('/start_webcam', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    statusElem.textContent = 'Local camera active: ' + data.message;
                    videoStatusElem.textContent = 'Local camera active: Ready for object detection and tracking'; 
                    statusElem.className = 'status success';
                    updateCameraStatus('Connected', true);
                    document.getElementById('startWebcamBtn').disabled = true;
                    document.getElementById('stopWebcamBtn').disabled = false;

                    // Update video feed source
                    const videoElem = document.getElementById('videoFeed');
                    const trackingEnabled = getTrackingEnabled();

                    // Show video element, hide placeholder
                    document.getElementById('placeholder').style.display = 'none';
                    videoElem.style.display = 'block';

                    // Set current video to special webcam indicator
                    currentVideo = 'webcam';
                    isPlaying = true;

                    // Update control buttons
                    updateControlButtons();

                    // Set source to webcam feed with tracking parameters
                    const webcamUrl = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
                    console.log("Setting webcam URL to:", webcamUrl);
                    videoElem.src = webcamUrl;
                    videoElem.classList.add('active');

                    // Set up error handling for video feed
                    videoElem.onerror = function() {
                        console.error("Error loading webcam feed");
                        statusElem.textContent = 'Error receiving webcam feed';
                        videoStatusElem.textContent = 'Error receiving webcam feed';
                        statusElem.className = 'status error';
                        updateCameraStatus('Error', false);
                        // Try to recover
                        retryWebcamFeed(3);
                    };
                } else {
                    document.getElementById('startWebcamBtn').disabled = false;
                    statusElem.textContent = `Error: ${data.message}`;
                    videoStatusElem.textContent = `Error: ${data.message}`;
                    statusElem.className = 'status error';
                    updateCameraStatus('Connection failed', false);
                }
            } catch (error) {
                console.error('Error starting webcam:', error);
                document.getElementById('startWebcamBtn').disabled = false;
                statusElem.textContent = 'Failed to start webcam: ' + error.message;
                videoStatusElem.textContent = 'Failed to start webcam: ' + error.message;
                statusElem.className = 'status error';
                updateCameraStatus('Connection failed', false);
            }
        }
        
        // Retry webcam feed if it fails
        async function retryWebcamFeed(retriesLeft) {
            if (retriesLeft <= 0) {
                document.getElementById('webcamStatus').textContent = 'Could not connect to webcam after retries';
                document.getElementById('videoStatus').textContent = 'Could not connect to webcam after multiple attempts';
                document.getElementById('startWebcamBtn').disabled = false;
                document.getElementById('stopWebcamBtn').disabled = true;
                return;
            }
            
            console.log(`Retrying webcam feed, ${retriesLeft} attempts left`);
            document.getElementById('videoStatus').textContent = `Reconnecting to webcam (${retriesLeft} attempts left)...`;
            
            // Wait a moment before retry
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const videoElem = document.getElementById('videoFeed');
            const trackingEnabled = getTrackingEnabled();
            
            // Add timestamp to URL to prevent caching
            const timestamp = new Date().getTime();
            videoElem.src = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}&t=${timestamp}`;
            
            videoElem.onerror = function() {
                retryWebcamFeed(retriesLeft - 1);
            };
        }
        
        // Stop webcam stream
        async function stopWebcam() {
            const statusElem = document.getElementById('webcamStatus');
            const videoStatusElem = document.getElementById('videoStatus');
            
            try {
                statusElem.textContent = 'Stopping webcam...';
                videoStatusElem.textContent = 'Stopping webcam...';
                statusElem.className = 'status';
                updateCameraStatus('Disconnecting...', false);
                
                // Check if using browser camera
                if (window.browserStream) {
                    stopBrowserCamera();
                }
                
                const response = await fetch('/stop_webcam', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    statusElem.textContent = 'Webcam stopped';
                    videoStatusElem.textContent = 'Webcam stopped';
                    statusElem.className = 'status';
                    updateCameraStatus('Disconnected', false);
                    document.getElementById('startWebcamBtn').disabled = false;
                    document.getElementById('stopWebcamBtn').disabled = true;
                    
                    // Hide video feed
                    const videoElem = document.getElementById('videoFeed');
                    videoElem.src = '';
                    videoElem.classList.remove('active');
                    
                    // Reset video state
                    currentVideo = null;
                    isPlaying = false;
                    updateControlButtons();
                    
                    // Show placeholder
                    document.getElementById('placeholder').style.display = 'block';
                    videoElem.style.display = 'none';
                    
                    // Reset selected object
                    selectedObjectId = null;
                } else {
                    statusElem.textContent = `Error: ${data.message}`;
                    videoStatusElem.textContent = `Error: ${data.message}`;
                    statusElem.className = 'status warning';
                }
            } catch (error) {
                console.error('Error stopping webcam:', error);
                statusElem.textContent = 'Failed to stop webcam: ' + error.message;
                videoStatusElem.textContent = 'Failed to stop webcam: ' + error.message;
                statusElem.className = 'status error';
            }
        }

        // Get tracking state based on current source
        function getTrackingEnabled() {
            if (activeSource === 'webcam') {
                return document.getElementById('webcamTrackingToggle').checked;
            } else {
                return true; // Always enabled for video mode
            }
        }

        // Toggle webcam tracking
        function toggleWebcamTracking() {
            // Only applies to webcam mode
            if (activeSource === 'webcam' && currentVideo === 'webcam') {
                const trackingEnabled = document.getElementById('webcamTrackingToggle').checked;
                const videoElem = document.getElementById('videoFeed');
                
                console.log("Updating webcam feed with tracking:", trackingEnabled);
                
                // Update status text
                if (trackingEnabled) {
                    document.getElementById('videoStatus').textContent = selectedObjectId 
                        ? `Tracking object ID: ${selectedObjectId}` 
                        : 'Detecting all objects...';
                } else {
                    document.getElementById('videoStatus').textContent = 'Webcam streaming (tracking disabled)';
                }
                
                // Webcam is active, update with tracking parameter
                videoElem.src = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
            }
        }

        // Set up object tracking by ID
        function trackObject(objectId) {
            // If objectId is not provided, try to get it from the input element
            if (!objectId) {
                const objectIdInput = document.getElementById('objectId');
                if (objectIdInput) {
                    objectId = objectIdInput.value;
                }
            }
            
            // Validate we have an object ID
            if (!objectId) {
                document.getElementById('videoStatus').textContent = 'Please specify an object ID to track';
                return;
            }
            
            selectedObjectId = objectId;
            const videoElem = document.getElementById('videoFeed');
            const trackingEnabled = getTrackingEnabled();
            
            console.log(`Tracking object ID: ${objectId}, activeSource: ${activeSource}, currentVideo: ${currentVideo}`);
            
            // Update status text
            document.getElementById('videoStatus').textContent = `Tracking object ID: ${objectId}`;
            
            // If webcam is active
            if (activeSource === 'webcam' && currentVideo === 'webcam') {
                videoElem.src = `/webcam_feed?tracking=${trackingEnabled}&object_id=${objectId}`;
            } 
            // If video upload is active
            else if (activeSource === 'video' && currentVideo && currentVideo !== 'webcam') {
                videoElem.src = `/video_feed?filename=${currentVideo}&tracking=${trackingEnabled}&object_id=${objectId}`;
            }
        }

        // Function to handle browser camera setup
        async function startBrowserCamera() {
            const statusElem = document.getElementById('webcamStatus');
            const videoStatusElem = document.getElementById('videoStatus');
            updateCameraStatus('Initializing browser camera...', false);
            statusElem.textContent = 'Requesting camera permission...';
            videoStatusElem.textContent = 'Requesting camera permission...';
            
            try {
                // Create video element for browser camera
                if (!window.browserVideoElement) {
                    window.browserVideoElement = document.createElement('video');
                    window.browserVideoElement.id = 'browserVideo';
                    window.browserVideoElement.style.display = 'none';
                    window.browserVideoElement.autoplay = true;
                    window.browserVideoElement.muted = true;
                    window.browserVideoElement.playsInline = true;
                    document.body.appendChild(window.browserVideoElement);
                }
                
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error("Browser doesn't support camera access (getUserMedia API)");
                }
                
                // Try to get camera with ideal settings first
                let stream = null;
                try {
                    console.log("Attempting to access camera with ideal settings...");
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }, 
                        audio: false 
                    });
                } catch (err) {
                    console.log("Failed with ideal settings, trying basic settings...", err);
                    // Try with minimal constraints
                    stream = await navigator.mediaDevices.getUserMedia({ 
                        video: true, 
                        audio: false 
                    });
                }
                
                if (!stream) {
                    throw new Error("Could not get camera stream");
                }
                
                // Connect stream to video element
                window.browserVideoElement.srcObject = stream;
                window.browserStream = stream;
                
                // Wait for video to be ready with timeout
                await Promise.race([
                    new Promise(resolve => {
                        window.browserVideoElement.onloadedmetadata = resolve;
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout waiting for camera")), 5000))
                ]);
                
                // Start playing to get access to video frames
                await window.browserVideoElement.play();
                
                // Update UI
                statusElem.textContent = 'Browser camera active';
                videoStatusElem.textContent = 'Browser camera active: Ready for object detection and tracking';
                statusElem.className = 'status success';
                updateCameraStatus('Connected', true);
                document.getElementById('startWebcamBtn').disabled = true;
                document.getElementById('stopWebcamBtn').disabled = false;
                
                // Update server that we're using browser camera
                const formData = new FormData();
                formData.append('camera_id', 'browser');
                await fetch('/start_webcam', {
                    method: 'POST',
                    body: formData
                });
                
                // Show video element, hide placeholder
                document.getElementById('placeholder').style.display = 'none';
                const videoElem = document.getElementById('videoFeed');
                videoElem.style.display = 'block';
                
                // Set current video to special webcam indicator
                currentVideo = 'webcam';
                isPlaying = true;
                
                // Update control buttons
                updateControlButtons();
                
                // Set source to webcam feed with tracking parameters
                const trackingEnabled = getTrackingEnabled();
                const webcamUrl = `/webcam_feed?tracking=${trackingEnabled}${selectedObjectId ? `&object_id=${selectedObjectId}` : ''}`;
                console.log("Setting webcam URL to:", webcamUrl);
                videoElem.src = webcamUrl;
                videoElem.classList.add('active');
                
                // Start sending frames to server
                startBrowserFrameCapture();
                
            } catch (error) {
                console.error('Error starting browser camera:', error);
                let errorMessage = error.name === 'NotAllowedError' 
                    ? 'Camera access denied. Please allow camera access and try again.' 
                    : error.message || 'Could not start video source';
                    
                // Add troubleshooting guidance
                const troubleshooting = 'Troubleshooting: Make sure no other app is using your camera and try reloading the page.';
                
                statusElem.textContent = 'Failed to start browser camera: ' + errorMessage;
                videoStatusElem.textContent = 'Camera error: ' + errorMessage + '. ' + troubleshooting;
                statusElem.className = 'status error';
                updateCameraStatus('Camera access failed', false);
                document.getElementById('startWebcamBtn').disabled = false;
            }
        }

        // Function to stop browser camera
        function stopBrowserCamera() {
            if (window.browserStream) {
                // Stop all tracks
                window.browserStream.getTracks().forEach(track => track.stop());
                window.browserStream = null;
            }
            
            if (window.frameCapture) {
                clearInterval(window.frameCapture);
                window.frameCapture = null;
            }
            
            if (window.browserVideoElement) {
                window.browserVideoElement.srcObject = null;
            }
            
            console.log("Browser camera stopped");
        }

        // Function to capture and send frames from browser camera to server
        function startBrowserFrameCapture() {
            // Clear any existing interval
            if (window.frameCapture) {
                clearInterval(window.frameCapture);
            }
            
            // Create canvas for frame capture if it doesn't exist
            if (!window.captureCanvas) {
                window.captureCanvas = document.createElement('canvas');
                window.captureCanvasCtx = window.captureCanvas.getContext('2d');
            }
            
            const video = window.browserVideoElement;
            const canvas = window.captureCanvas;
            const ctx = window.captureCanvasCtx;
            
            if (!video || !video.srcObject || !ctx) {
                console.error("Cannot start frame capture - video element or context not ready");
                document.getElementById('videoStatus').textContent = 'Error: Camera initialization failed';
                return;
            }
            
            // Set canvas size to match video
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            
            console.log(`Starting frame capture at ${canvas.width}x${canvas.height}`);
            
            // Track consecutive errors
            let errorCount = 0;
            const MAX_ERRORS = 5;
            
            // Capture and send frames at regular interval
            window.frameCapture = setInterval(async () => {
                // Early exit checks
                if (!video.srcObject) {
                    console.log("Video source disconnected");
                    clearInterval(window.frameCapture);
                    window.frameCapture = null;
                    return;
                }
                
                // Don't send frames if paused
                if (!isPlaying) {
                    return;
                }
                
                try {
                    // Draw current video frame to canvas
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // Convert to blob
                    const blob = await new Promise((resolve, reject) => {
                        canvas.toBlob(blob => {
                            if (blob) resolve(blob);
                            else reject(new Error("Failed to create blob"));
                        }, 'image/jpeg', 0.8);
                    });
                    
                    // Send to server
                    const formData = new FormData();
                    formData.append('file', blob, 'browser-frame.jpg');
                    
                    const response = await fetch('/browser_camera_frame', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Server rejected frame: ${response.status}`);
                    }
                    
                    // Reset error count on success
                    errorCount = 0;
                    
                } catch (error) {
                    errorCount++;
                    console.error(`Error sending frame to server (${errorCount}/${MAX_ERRORS}):`, error);
                    
                    // If we've had too many consecutive errors, stop the capture
                    if (errorCount >= MAX_ERRORS) {
                        console.error("Too many frame capture errors, stopping capture");
                        document.getElementById('videoStatus').textContent = 'Error: Connection to server lost. Please refresh the page.';
                        clearInterval(window.frameCapture);
                        window.frameCapture = null;
                    }
                }
            }, 100); // Send ~10 FPS - adjust for performance
        }

        // Add resize event listener to handle canvas resizing
        window.addEventListener('resize', () => {
            if (isDrawingMode) {
                initializeCanvas();
            }
        });
    </script>
    
    <!-- Browser Camera Access Functions -->
    <script>
        // The original browser camera functions are being replaced by the newer implementation
        // Keep the function wrappers for backward compatibility if needed
        
        // Redirect to the new functions
        function accessBrowserCamera() {
            const cameraSelect = document.getElementById('cameraSelect');
            cameraSelect.value = "browser";
            startWebcam(); // Use the main webcam function with browser selected
        }
        
        // Update the togglePlay function to use the newer implementation
        const originalTogglePlay = togglePlay;
        togglePlay = function() {
            // Use the standard togglePlay implementation that already has browser camera handling
            originalTogglePlay();
        }
        
        // Update the stopVideo function to use the newer implementation
        const originalStopVideo = stopVideo;
        stopVideo = function() {
            // Use the standard stopVideo implementation that already has browser camera handling
            originalStopVideo();
        }
    </script>
  </body>
</html>
